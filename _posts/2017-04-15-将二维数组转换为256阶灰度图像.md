---
title:  "将二维数组转换为256阶灰度图像(C#)"
date:   2017-04-15 14:35
categories: CSharp
---

>假设有nx*ny的二维数组Mat，如何将其映射到[0~255](256灰度级)范围并显示在一张图片里？
下面以UInt16(16bit无符号整数，在32bit环境下为unsigned short)类型Mat为例说明。

```csharp
using System;
using System.Drawing;
using System.Drawing.Imaging;

namespace ArrayToGrayAlg
{
    public class ArrayToGray
    {
        /// 将更大的区间映射到[0,255]上
        private static void ToGrayScale(UInt16[] src, byte[] dst, int ns)
        {
            // UInt16.Max=65536-1
            // byte.Max=256-1
            // 65536/256=256
            // dst=src/256
            for (int i = 0; i < ns; ++i)
            {
                dst[i] = (byte)(src[i] >> 8);
            }
        }

         /// 直方图均衡化，增强图像显示效果
        public static void EqualizeHistToGray(UInt16[] src, byte[] dst, int ns)
        {
            byte[] tmp = new byte[ns];
            ToGrayScale(src, tmp, ns);

            const int ng = 256; //0~255
            int[] H = new int[ng];   //直方图
            int[] Hc = new int[ng];  //累积直方图
            byte[] T = new byte[ng];

            int i, k;
            for (i = 0; i < ns; ++i)
            {
                k = tmp[i];
                ++H[k];
            }

            double scale = 255.0 / ns; // (ng-1)/ns
            Hc[0] = H[0];
            for (i = 1; i < ng; ++i)
            {
                Hc[i] = Hc[i - 1] + H[i];
                T[i] = (byte)(Hc[i] * scale + 0.5);
            }

            for (i = 0; i < ns; ++i)
            {
                k = tmp[i];
                dst[i] = T[k];
            }
        }

        /// 转bitmap，可以用PictureBox.Image=Bitmap方式来显示（代码是copy来的）
        public static Bitmap ToGrayBitmap(byte[] rawValues, int width, int height)
        {
            //// 申请目标位图的变量，并将其内存区域锁定  
            Bitmap bmp = new Bitmap(width, height, PixelFormat.Format8bppIndexed);
            BitmapData bmpData = bmp.LockBits(new Rectangle(0, 0, width, height),
                             ImageLockMode.WriteOnly, PixelFormat.Format8bppIndexed);

            //// 获取图像参数  
            int stride = bmpData.Stride;  // 扫描线的宽度  
            int offset = stride - width;  // 显示宽度与扫描线宽度的间隙  
            IntPtr iptr = bmpData.Scan0;  // 获取bmpData的内存起始位置  
            int scanBytes = stride * height;// 用stride宽度，表示这是内存区域的大小  

            //// 下面把原始的显示大小字节数组转换为内存中实际存放的字节数组  
            int posScan = 0, posReal = 0;// 分别设置两个位置指针，指向源数组和目标数组  
            byte[] pixelValues = new byte[scanBytes];  //为目标数组分配内存  

            for (int x = 0; x < height; x++)
            {
                //// 下面的循环节是模拟行扫描  
                for (int y = 0; y < width; y++)
                {
                    pixelValues[posScan++] = rawValues[posReal++];
                }
                posScan += offset;  //行扫描结束，要将目标位置指针移过那段“间隙”  
            }

            //// 用Marshal的Copy方法，将刚才得到的内存字节数组复制到BitmapData中  
            System.Runtime.InteropServices.Marshal.Copy(pixelValues, 0, iptr, scanBytes);
            bmp.UnlockBits(bmpData);  // 解锁内存区域  

            //// 下面的代码是为了修改生成位图的索引表，从伪彩修改为灰度  
            ColorPalette tempPalette;
            using (Bitmap tempBmp = new Bitmap(1, 1, PixelFormat.Format8bppIndexed))
            {
                tempPalette = tempBmp.Palette;
            }
            for (int i = 0; i < 256; i++)
            {
                tempPalette.Entries[i] = Color.FromArgb(i, i, i);
            }

            bmp.Palette = tempPalette;

            //// 算法到此结束，返回结果  
            return bmp;
        }  
    }
}
```